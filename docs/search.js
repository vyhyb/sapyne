window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "sapyne", "modulename": "sapyne", "kind": "module", "doc": "<h1 id=\"sapyne\">Sapyne</h1>\n\n<p>Sapyne is a Python package for basic room acoustics calculations. \nIt provides functions to calculate the attenuation coefficient, \nabsorption area, reverberation time, and (in the future) other room \nacoustics parameters. It mostly serves for room acoustic design according\nto the \u010cSN 73 0527 standard.</p>\n\n<h2 id=\"installation\">Installation</h2>\n\n<p>It is currently not possible to install this library using <code>pip</code> or <code>conda</code>, \nplease use the latest released package instead and install using \n<a href=\"https://packaging.python.org/en/latest/tutorials/installing-packages/\"><code>pip</code> locally</a>.</p>\n\n<h2 id=\"documentation\">Documentation</h2>\n\n<p>Documentation can be found <a href=\"https://vyhyb.github.io/sapyne/\">here</a>.</p>\n\n<h2 id=\"usage\">Usage</h2>\n\n<p>Will be added in the future.</p>\n\n<h2 id=\"author\">Author</h2>\n\n<ul>\n<li><p><a href=\"https://www.fce.vutbr.cz/o-fakulte/lide/david-jun-12801/\">David Jun</a></p>\n\n<p>PhD student at <a href=\"https://www.vutbr.cz/en/\">Brno University of Technology</a>.</p></li>\n</ul>\n\n<h2 id=\"contributing\">Contributing</h2>\n\n<p>Pull requests are welcome. For any changes, please open an issue first\nto discuss what you would like to change.</p>\n\n<p>Please make sure to update tests as appropriate.</p>\n\n<h2 id=\"license\">License</h2>\n\n<p><a href=\"https://choosealicense.com/licenses/gpl-3.0/\">GNU GPLv3</a></p>\n\n<h2 id=\"references\">References</h2>\n\n<ul>\n<li>[1] \u010cSN 730525 -  Akustika - Projektov\u00e1n\u00ed v oboru prostorov\u00e9 akustiky - V\u0161eobecn\u00e9 z\u00e1sady, Praha, manual, 1998.</li>\n<li>[2] \u010cSN 730526 - Akustika - Projektov\u00e1n\u00ed v oboru prostorov\u00e9 akustiky - Studia a m\u00edstnosti pro sn\u00edm\u00e1n\u00ed, zpracov\u00e1n\u00ed a kontrolu zvuku, \u010cesk\u00fd normaliza\u010dn\u00ed institut, Praha, manual, 1998.</li>\n<li>[3] \u010cSN 730527 - Akustika - Projektov\u00e1n\u00ed v oboru prostorov\u00e9 akustiky. Prostory pro kulturn\u00ed a \u0161koln\u00ed \u00fa\u010dely. Prostory pro ve\u0159ejn\u00e9 \u00fa\u010dely. Administrativn\u00ed pracovny, Praha, manual, 2005.</li>\n<li>[4] \u010cSN EN ISO 3382-1   (730534) - Akustika - M\u011b\u0159en\u00ed parametr\u016f prostorov\u00e9 akustiky - \u010c\u00e1st 1: Prostory pro p\u0159ednes hudby a \u0159e\u010di, manual, Praha., 2009.</li>\n<li>[5] \u010cSN EN ISO 3382-2   (730534) - Akustika - M\u011b\u0159en\u00ed parametr\u016f prostorov\u00e9 akustiky - \u010c\u00e1st 2: Doba dozvuku v b\u011b\u017en\u00fdch prostorech, manual, Praha., 2009.</li>\n<li>[6] ISO 3382-3:2022 - Acoustics - Measurement of room acoustic parameters - Part 3: Open plan offices, Geneve., 2022. Accessed: Nov. 09, 2022. [Online]. Available: <a href=\"https://www.iso.org/standard/77437.html\">https://www.iso.org/standard/77437.html</a></li>\n<li>[7] ISO 354:2003 Acoustics - Measurement of sound absorption in a reverberation room, Geneva, Switzerland., May 2003. [Online]. Available: <a href=\"https://www.iso.org/standard/34545.html\">https://www.iso.org/standard/34545.html</a></li>\n<li>[8] ISO 9613-1:1993 - Acoustics - Attenuation of sound during propagation outdoors - Part 1: Calculation of the absorption of sound by the atmosphere, Geneve., 1993.</li>\n</ul>\n"}, {"fullname": "sapyne.attenuation", "modulename": "sapyne.attenuation", "kind": "module", "doc": "<p>Sound attenuation in air</p>\n"}, {"fullname": "sapyne.attenuation.attenuation_coefficient", "modulename": "sapyne.attenuation", "qualname": "attenuation_coefficient", "kind": "function", "doc": "<p>Calculate the sound attenuation coefficient in air based on the given criteria.\nAccording to ISO 9613-1:1993.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>frequency</strong> (float|np.ndarray|Series):\nFrequency bands for the calculation. [Hz]</li>\n<li><strong>relative_humidity</strong> (float):\nRelative humidity at the time of measurement. [%]</li>\n<li><strong>temperature</strong> (float):\nAir temperature at the time of measurement. [degC]</li>\n<li><strong>pressure</strong> (float):\nAtmospheric pressure at the time of measurement. [kPa]</li>\n<li><strong>norm_pressure</strong> (float, optional):\nNormal atmospheric pressure (reference). Default is 101.325.</li>\n<li><strong>temperature_0</strong> (float, optional):\nReference temperature (20 \u00b0C). Default is 293.15.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>att_coeff</strong> (float):\nSound attenuation coefficient.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The sound attenuation coefficient is calculated using the following formulas:\n$$\nC = -6.8346 \\left( \\frac{273.16}{T} \\right)^{1.261} + 4.6151\n$$\nwhere:</p>\n\n<ul>\n<li>$T$ is the temperature [K]</li>\n<li>$T_0$ is the reference temperature [K]</li>\n</ul>\n\n<p>$$\np_{sat} = p_r \\cdot 10^C\n$$\nwhere:</p>\n\n<ul>\n<li>$p_{sat}$ is the saturation pressure [kPa]</li>\n<li>$p_r$ is the normal pressure [kPa]</li>\n</ul>\n\n<p>$$\nh = h_r \\cdot \\frac{p_{sat}}{p_r} \\cdot \\frac{p_r}{p_a}\n$$\nwhere:</p>\n\n<ul>\n<li>$h$ is the ...</li>\n<li>$h_r$ is the relative humidity [%]</li>\n<li>$p_a$ is the atmospheric pressure [kPa]</li>\n</ul>\n\n<p>$$\nf_{rO} = \\frac{p_a}{p_r} \\left( 24 + 4.04 \\times 10^4 \\cdot \n\\frac{h \\cdot (0.02 + h)}{0.391 + h} \\right)\n$$\nwhere:</p>\n\n<ul>\n<li>$f_{rO}$ is the relaxation frequency of oxygen [Hz]</li>\n</ul>\n\n<p>$$\nf_{rN} = \\frac{p_a}{p_r} \\left( \\frac{T}{T_0} \\right)^{-0.5} \n\\left( 9 + 280 \\cdot h \\cdot \\exp \\left( -4.170 \\left( \\left( \n    \\frac{T}{T_0} \\right)^{-1/3} - 1 \n\\right) \\right) \\right)\n$$\nwhere:</p>\n\n<ul>\n<li>$f_{rN}$ is the relaxation frequency of nitrogen [Hz]</li>\n</ul>\n\n<p>$$\n\\alpha = 8.686 \\cdot f^2 \\left( \\left( 1.84 \\times 10^{-11} \\cdot \n\\frac{p_r}{p_a} \\cdot \\left( \\frac{T}{T_0} \\right)^{0.5} \\right) + \n\\left( \\left( \\frac{T}{T_0} \\right)^{-5/2} \n\\left( 0.01275 \\cdot \\left( f_{rO} + \\frac{f^2}{f_{rO}} \\right)^{-1} \\cdot \\exp \\left( -\\frac{2239.1}{T} \\right) \n+ 0.1068 \\cdot \\left( f_{rN} + \\frac{f^2}{f_{rN}} \\right)^{-1} \\cdot \\exp \\left( -\\frac{3352.0}{T} \n\\right) \\right) \\right) \\right)\n$$\nwhere:\n- $\\alpha$ is the sound attenuation coefficient [dB/m]</p>\n\n<p>$$\nm = \\frac{\\alpha}{10 \\cdot \\log_{10} e}\n$$\nwhere:</p>\n\n<ul>\n<li>$m$ is the sound attenuation coefficient used in the ISO 354 and ISO 3382 standards [m\u207b\u00b9]</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">frequency</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>,</span><span class=\"param\">\t<span class=\"n\">relative_humidity</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">temperature</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">pressure</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">norm_pressure</span><span class=\"o\">=</span><span class=\"mf\">101.325</span>,</span><span class=\"param\">\t<span class=\"n\">temp_ref</span><span class=\"o\">=</span><span class=\"mf\">293.15</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "sapyne.experimental_absorption", "modulename": "sapyne.experimental_absorption", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sapyne.experimental_absorption.eq_absorption_area", "modulename": "sapyne.experimental_absorption", "qualname": "eq_absorption_area", "kind": "function", "doc": "<p>Returns the equivalent absorption area based on the given parameters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>volume</strong> (float):\nRoom volume. [m\u00b3]</li>\n<li><strong>rt_60</strong> (array-like):\nReverberation time. [s]</li>\n<li><strong>attenuation_coef</strong> (array-like, optional):\nSound attenuation coefficient in air. Default is 0. [m\u207b\u00b9]</li>\n<li><strong>speed_sound</strong> (float, optional):\nSpeed of sound in air. Default is 340. [m/s]</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: Equivalent absorption area. [m\u00b2]</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The equivalent absorption area $A$ is calculated using the formula:\n$$\nA = \\frac{55.3 \\cdot V}{c \\cdot RT_{60}} - 4 \\cdot m \\cdot V\n$$\nwhere:</p>\n\n<ul>\n<li>$V$ is the room volume [m\u00b3]</li>\n<li>$RT_{60}$ is the reverberation time [s]</li>\n<li>$m$ is the sound attenuation coefficient in air [m\u207b\u00b9]</li>\n<li>$c$ is the speed of sound in air [m/s]</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">rt_60</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">attenuation_coef</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">speed_sound</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">343</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sapyne.experimental_absorption.absorption_coeff_ISO_354_mean", "modulename": "sapyne.experimental_absorption", "qualname": "absorption_coeff_ISO_354_mean", "kind": "function", "doc": "<p>Calculate the absorption coefficient using ISO 354 standard.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>absorption_sample</strong> (np.ndarray):\nTotal absorption of the room with the sample placed inside. [m\u00b2]</li>\n<li><strong>absorption_reference</strong> (np.ndarray):\nTotal absorption of the empty room. [m\u00b2]</li>\n<li><strong>specimen_area</strong> (float):\nArea of the sample specimen. [m\u00b2]</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: Absorption coefficient calculated using ISO 354 standard. [dimensionless]</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The absorption coefficient $\\alpha$ is calculated using the formula:\n$$\n\\alpha = \\frac{A_s - A_r}{S}\n$$\nwhere:</p>\n\n<ul>\n<li>$A_s$ is the total absorption of the room with the sample placed inside [m\u00b2]</li>\n<li>$A_r$ is the total absorption of the empty room [m\u00b2]</li>\n<li>$S$ is the area of the sample specimen [m\u00b2]</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">absorption_sample</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">absorption_reference</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">specimen_area</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "sapyne.experimental_absorption.absorption_coeff_ISO_354_std", "modulename": "sapyne.experimental_absorption", "qualname": "absorption_coeff_ISO_354_std", "kind": "function", "doc": "<p>Calculate the absorption coefficient standard deviation using \nerror propagation of the total absorption.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>absorption_sample_std</strong> (np.ndarray):\nStandard deviation of the total absorption of the room with the\nsample placed inside. [m\u00b2]</li>\n<li><strong>absorption_reference_std</strong> (np.ndarray):\nStandard deviation of the total absorption of the empty room. [m\u00b2]</li>\n<li><strong>specimen_area</strong> (float):\nArea of the sample specimen. [m\u00b2]</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: Absorption coefficient standard deviation calculated using \nstandard error propagation. [dimensionless]</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The standard deviation of the absorption coefficient $\\sigma_\\alpha$ is calculated using the formula:\n$$\n\\sigma_\\alpha = \\frac{\\sqrt{\\sigma_{A_s}^2 + \\sigma_{A_r}^2}}{S}\n$$\nwhere:</p>\n\n<ul>\n<li>$\\sigma_{A_s}$ is the standard deviation of the total absorption of the room with the sample placed inside [m\u00b2]</li>\n<li>$\\sigma_{A_r}$ is the standard deviation of the total absorption of the empty room [m\u00b2]</li>\n<li>$S$ is the area of the sample specimen [m\u00b2]</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">absorption_sample_std</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">absorption_reference_std</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">specimen_area</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "sapyne.experimental_absorption.absorption_coeff_ISO_354", "modulename": "sapyne.experimental_absorption", "qualname": "absorption_coeff_ISO_354", "kind": "function", "doc": "<p>Calculate the absorption coefficient using ISO 354 standard.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>absorption_sample</strong> (np.ndarray):\nTotal absorption of the room with the sample placed inside. [m\u00b2]</li>\n<li><strong>absorption_reference</strong> (np.ndarray):\nTotal absorption of the empty room. [m\u00b2]</li>\n<li><strong>absorption_sample_std</strong> (np.ndarray):\nStandard deviation of the total absorption of the room with the sample placed inside. [m\u00b2]</li>\n<li><strong>absorption_reference_std</strong> (np.ndarray):\nStandard deviation of the total absorption of the empty room. [m\u00b2]</li>\n<li><strong>specimen_area</strong> (float):\nArea of the sample specimen. [m\u00b2]</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>absorption_coeff</strong> (np.ndarray):\nAbsorption coefficient calculated using ISO 354 standard. [dimensionless]</li>\n<li><strong>absorption_coeff_std</strong> (np.ndarray):\nAbsorption coefficient standard deviation calculated using ISO 354 standard. [dimensionless]</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The absorption coefficient $\\alpha$ and its standard deviation $\\sigma_\\alpha$ are calculated using the formulas:\n$$\n\\alpha = \\frac{A_s - A_r}{S}\n$$\n$$\n\\sigma_\\alpha = \\frac{\\sqrt{\\sigma_{A_s}^2 + \\sigma_{A_r}^2}}{S}\n$$\nwhere:</p>\n\n<ul>\n<li>$A_s$ is the total absorption of the room with the sample placed inside [m\u00b2]</li>\n<li>$A_r$ is the total absorption of the empty room [m\u00b2]</li>\n<li>$\\sigma_{A_s}$ is the standard deviation of the total absorption of the room with the sample placed inside [m\u00b2]</li>\n<li>$\\sigma_{A_r}$ is the standard deviation of the total absorption of the empty room [m\u00b2]</li>\n<li>$S$ is the area of the sample specimen [m\u00b2]</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">absorption_sample</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">absorption_reference</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">absorption_sample_std</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">absorption_reference_std</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">specimen_area</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sapyne.models", "modulename": "sapyne.models", "kind": "module", "doc": "<p>This module provides functions to calculate reverberation time (T60) using different methods:\nSabine, Eyring, Mellington, and CSN 730525. The calculations are based on absorption data,\nvolume, surface area, and attenuation.</p>\n\n<p>Functions:</p>\n\n<ul>\n<li><code>calc_alpha_mean</code>: Calculate the mean absorption coefficient.</li>\n<li><code>t60_sabine</code>: Calculate T60 using the Sabine formula.</li>\n<li><code>t60_eyring</code>: Calculate T60 using the Eyring formula.</li>\n<li><code>t60_mellington</code>: Calculate T60 using the Mellington formula.</li>\n<li><code>t60_csn730525</code>: Calculate T60 using the CSN 730525 standard.</li>\n</ul>\n"}, {"fullname": "sapyne.models.calc_alpha_mean", "modulename": "sapyne.models", "qualname": "calc_alpha_mean", "kind": "function", "doc": "<p>Calculate the mean absorption coefficient.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>absorption</strong> (DataFrame):\nAbsorption data for different frequencies.</li>\n<li><strong>surface_sum</strong> (float):\nTotal surface area of the room [m\u00b2].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Series</strong>: Mean absorption coefficient for each frequency.</li>\n</ul>\n\n<h6 id=\"equation\">Equation</h6>\n\n<p>$$\n\\alpha_{\\text{mean}} = \\frac{\\sum \\alpha}{S}\n$$\nwhere:</p>\n\n<ul>\n<li>$\\alpha_{\\text{mean}}$ is the mean absorption coefficient</li>\n<li>$\\sum \\alpha$ is the sum of absorption coefficients</li>\n<li>$S$ is the total surface area [m\u00b2]</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">absorption</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">surface_sum</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">bands</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;125&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;250&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;500&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;1000&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;2000&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;4000&#39;</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "sapyne.models.t60_sabine", "modulename": "sapyne.models", "qualname": "t60_sabine", "kind": "function", "doc": "<p>Calculate T60 using the Sabine formula.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>absorption</strong> (DataFrame):\nAbsorption data for different frequencies.</li>\n<li><strong>volume</strong> (float):\nVolume of the room [m\u00b3].</li>\n<li><strong>constant</strong> (float, optional):\nA constant, default is 0.163.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Series</strong>: T60 for each frequency [s].</li>\n</ul>\n\n<h6 id=\"equation\">Equation</h6>\n\n<p>$$\nT_{60} = \\frac{0.163 \\cdot V}{\\sum \\alpha}\n$$\nwhere:</p>\n\n<ul>\n<li>$T_{60}$ is the reverberation time [s]</li>\n<li>$V$ is the volume of the room [m\u00b3]</li>\n<li>$\\sum \\alpha$ is the sum of absorption coefficients</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">absorption</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">constant</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.163</span>,</span><span class=\"param\">\t<span class=\"n\">bands</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;125&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;250&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;500&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;1000&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;2000&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;4000&#39;</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "sapyne.models.t60_eyring", "modulename": "sapyne.models", "qualname": "t60_eyring", "kind": "function", "doc": "<p>Calculate T60 using the Eyring formula.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>absorption</strong> (DataFrame):\nAbsorption data for different frequencies.</li>\n<li><strong>volume</strong> (float):\nVolume of the room [m\u00b3].</li>\n<li><strong>surface_sum</strong> (float):\nTotal surface area [m\u00b2].</li>\n<li><strong>constant</strong> (float, optional):\nA constant, default is 0.163.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Series</strong>: T60 for each frequency [s].</li>\n</ul>\n\n<h6 id=\"equation\">Equation</h6>\n\n<p>$$\nT_{60} = \\frac{0.163 \\cdot V}{-S \\cdot \\ln(1 - \\alpha_{\\text{mean}})}\n$$\nwhere:</p>\n\n<ul>\n<li>$T_{60}$ is the reverberation time [s]</li>\n<li>$V$ is the volume of the room [m\u00b3]</li>\n<li>$S$ is the total surface area [m\u00b2]</li>\n<li>$\\alpha_{\\text{mean}}$ is the mean absorption coefficient</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">absorption</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">surface_sum</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">constant</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.163</span>,</span><span class=\"param\">\t<span class=\"n\">bands</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;125&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;250&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;500&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;1000&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;2000&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;4000&#39;</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "sapyne.models.t60_mellington", "modulename": "sapyne.models", "qualname": "t60_mellington", "kind": "function", "doc": "<p>Calculate T60 using the Mellington formula.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>absorption</strong> (DataFrame):\nAbsorption data for different frequencies.</li>\n<li><strong>volume</strong> (float):\nVolume of the room [m\u00b3].</li>\n<li><strong>surface_sum</strong> (float):\nTotal surface area [m\u00b2].</li>\n<li><strong>attenuation</strong> (Series):\nAttenuation data for different frequencies.</li>\n<li><strong>constant</strong> (float, optional):\nA constant, default is 0.163.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Series</strong>: T60 for each frequency [s].</li>\n</ul>\n\n<h6 id=\"equation\">Equation</h6>\n\n<p>$$\nT_{60} = \\frac{0.163 \\cdot V}{-S \\cdot \\ln(1 - \\alpha_{\\text{mean}}) - 4 \\cdot m \\cdot V}\n$$\nwhere:</p>\n\n<ul>\n<li>$T_{60}$ is the reverberation time [s]</li>\n<li>$V$ is the volume of the room [m\u00b3]</li>\n<li>$S$ is the total surface area [m\u00b2]</li>\n<li>$\\alpha_{\\text{mean}}$ is the mean absorption coefficient</li>\n<li>$m$ is the attenuation coefficient [m\u207b\u00b9]</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">absorption</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">surface_sum</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">attenuation</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>,</span><span class=\"param\">\t<span class=\"n\">constant</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.163</span>,</span><span class=\"param\">\t<span class=\"n\">bands</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;125&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;250&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;500&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;1000&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;2000&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;4000&#39;</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "sapyne.models.t60_csn730525", "modulename": "sapyne.models", "qualname": "t60_csn730525", "kind": "function", "doc": "<p>Calculate T60 using the CSN 730525 standard.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>absorption</strong> (DataFrame):\nAbsorption data for different frequencies.</li>\n<li><strong>volume</strong> (float):\nVolume of the room [m\u00b3].</li>\n<li><strong>surface_sum</strong> (float):\nTotal surface area [m\u00b2].</li>\n<li><strong>attenuation</strong> (Series):\nAttenuation data for different frequencies.</li>\n<li><strong>constant</strong> (float, optional):\nA constant, default is 0.163.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Series</strong>: T60 for each frequency [s].</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The method uses different formulas based on the mean absorption coefficient and volume:</p>\n\n<ul>\n<li>Sabine formula if $\\alpha_{\\text{mean}} &lt; 0.2$ and $V &lt; 2000$ m\u00b3</li>\n<li>Eyring formula if $0.2 &lt; \\alpha_{\\text{mean}} &lt; 0.8$ and $V &lt; 2000$ m\u00b3</li>\n<li>Mellington formula otherwise</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">absorption</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">surface_sum</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">attenuation</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>,</span><span class=\"param\">\t<span class=\"n\">constant</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.163</span>,</span><span class=\"param\">\t<span class=\"n\">bands</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;125&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;250&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;500&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;1000&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;2000&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;4000&#39;</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "sapyne.room", "modulename": "sapyne.room", "kind": "module", "doc": "<p>Room object for reverberation time calculations\naccording to Sabine and similar models.</p>\n\n<p>This module provides a Room object for calculating the reverberation time\naccording to Sabine and similar models. The Room object can be used to\nstore data about the room, such as volume, temperature, humidity, pressure,\nsurfaces, and objects. The Room object can also calculate the absorption\ncoefficients of the surfaces and objects, and calculate the mean absorption\ncoefficient for each frequency band.</p>\n\n<h6 id=\"classes\">Classes</h6>\n\n<ul>\n<li><code>Room</code>: Room object for reverberation time calculations.</li>\n</ul>\n"}, {"fullname": "sapyne.room.Room", "modulename": "sapyne.room", "qualname": "Room", "kind": "class", "doc": "<p>Room object for reverberation time calculations\naccording to Sabine and similar models.</p>\n"}, {"fullname": "sapyne.room.Room.__init__", "modulename": "sapyne.room", "qualname": "Room.__init__", "kind": "function", "doc": "<p>Room object for reverberation time calculations\naccording to Sabine and similar models.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>name</strong> (str):\nName of the room</li>\n<li><strong>description</strong> (str):\nShort description of the room</li>\n<li><strong>volume</strong> (float):\nNet volume of the room [m^3]</li>\n<li><strong>temperature</strong> (float):\nAssumed temperature in the room [degC]</li>\n<li><strong>humidity</strong> (float):\nAssumed relative humidity [%]</li>\n<li><strong>pressure</strong> (float):\nAssumed atmospheric pressure [kPa]</li>\n<li><strong>surfaces</strong> (DataFrame):\npandas.DataFrame containing absorption coefficient data.\nThe required columns are:\n<ul>\n<li>\"ID\" (material id from the library)</li>\n<li>\"Name\" (material name from the library)</li>\n<li>\"Area\" (area in the room)</li>\n<li>125 ... 4000 (central frequencies of the octave bands \ntypically used in room acoustics)</li>\n</ul></li>\n<li><strong>objects</strong> (DataFrame):\npandas.DataFrame containing absorption data about objects.\nThe required columns are:\nThe required columns are:\n<ul>\n<li>\"ID\" (material id from the library)</li>\n<li>\"Name\" (material name from the library)</li>\n<li>\"Amount\" (amount in the room)</li>\n<li>125 ... 4000 (absorption coefficient for the octave bands \ntypically used in room acoustics)</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">description</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">temperature</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">humidity</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">pressure</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">surfaces</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span> <span class=\"o\">=</span> <span class=\"n\">Empty</span> <span class=\"n\">DataFrame</span>\n<span class=\"n\">Columns</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">ID</span><span class=\"p\">,</span> <span class=\"n\">Name</span><span class=\"p\">,</span> <span class=\"n\">Area</span><span class=\"p\">,</span> <span class=\"mi\">125</span><span class=\"p\">,</span> <span class=\"mi\">250</span><span class=\"p\">,</span> <span class=\"mi\">500</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"mi\">2000</span><span class=\"p\">,</span> <span class=\"mi\">4000</span><span class=\"p\">]</span>\n<span class=\"n\">Index</span><span class=\"p\">:</span> <span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">objects</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span> <span class=\"o\">=</span> <span class=\"n\">Empty</span> <span class=\"n\">DataFrame</span>\n<span class=\"n\">Columns</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">ID</span><span class=\"p\">,</span> <span class=\"n\">Name</span><span class=\"p\">,</span> <span class=\"n\">Amount</span><span class=\"p\">,</span> <span class=\"mi\">125</span><span class=\"p\">,</span> <span class=\"mi\">250</span><span class=\"p\">,</span> <span class=\"mi\">500</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"mi\">2000</span><span class=\"p\">,</span> <span class=\"mi\">4000</span><span class=\"p\">]</span>\n<span class=\"n\">Index</span><span class=\"p\">:</span> <span class=\"p\">[]</span></span>)</span>"}, {"fullname": "sapyne.room.Room.add_surface", "modulename": "sapyne.room", "qualname": "Room.add_surface", "kind": "function", "doc": "<p>Add a surface to the room.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>library</strong> (DataFrame):\npandas.DataFrame containing absorption coefficient data.\nThe required columns are:\n<ul>\n<li>\"ID\" (material id from the library)</li>\n<li>\"Name\" (material name from the library)</li>\n<li>125 ... 4000 (central frequencies of the octave bands \ntypically used in room acoustics)</li>\n</ul></li>\n<li><strong>material_id</strong> (str):\nID of the material in the library</li>\n<li><strong>area</strong> (float):\nArea of the surface [m^2]</li>\n<li><strong>subtract_area_from</strong> (str):\nID of the surface to subtract the area from. \nThis is useful for windows and doors, where the area \nis subtracted from the wall area.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">library</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">material_id</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">area</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">subtract_area_from</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sapyne.room.Room.add_object", "modulename": "sapyne.room", "qualname": "Room.add_object", "kind": "function", "doc": "<p>Add an object to the room.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>library</strong> (DataFrame):\npandas.DataFrame containing absorption coefficient data.\nThe required columns are:\n<ul>\n<li>\"ID\" (material id from the library)</li>\n<li>\"Name\" (material name from the library)</li>\n<li>125 ... 4000 (central frequencies of the octave bands \ntypically used in room acoustics)</li>\n</ul></li>\n<li><strong>material_id</strong> (str):\nID of the material in the library</li>\n<li><strong>amount</strong> (float):\nAmount of the object in the room [m^2]</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">library</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">material_id</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">amount</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sapyne.rt_imports", "modulename": "sapyne.rt_imports", "kind": "module", "doc": "<p>Module for importing reverberation data from Dirac and REW.\nThe module contains classes for importing reverberation data from\nDirac and REW. The data is stored in a pandas DataFrame format.</p>\n\n<h2 id=\"classes\">Classes:</h2>\n\n<p>DiracReverberationData\nREWReverberationData</p>\n\n<h2 id=\"functions\">Functions:</h2>\n\n<p>merge_rew_dfs</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The DiracReverberationData class is used to import reverberation data\nfrom a txt file exported from Dirac, which typically contains more than\none measurement. </p>\n\n<p>The REWReverberationData class is used to import reverberation data from\na txt file exported from REW. Such measurement is typically a single \nmeasurement containing various quantities. In order to merge multiple\nmeasurements of one quantity, the merge_rew_dfs function is used.</p>\n\n<p>REW_QUANTITIES is a list of possible quantities that can be merged using\nthe merge_rew_dfs function.</p>\n"}, {"fullname": "sapyne.rt_imports.DiracReverberationData", "modulename": "sapyne.rt_imports", "qualname": "DiracReverberationData", "kind": "class", "doc": "<p>Representation of Dirac exported reverberation data.</p>\n\n<p>The object contains the data from the txt file exported from Dirac \nin a form of a pandas DataFrame.</p>\n\n<h2 id=\"structure\">Structure:</h2>\n\n<p>path : str\n    Path to the data file.\ndf : pandas.DataFrame\n    Reverberation data in a DataFrame format. Columns are the \n    frequency bands and the rows are the individual measurements.\ncols : np.ndarray\n    Frequency bands of the data.</p>\n"}, {"fullname": "sapyne.rt_imports.DiracReverberationData.__init__", "modulename": "sapyne.rt_imports", "qualname": "DiracReverberationData.__init__", "kind": "function", "doc": "<p>load the data from the given path.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\nPath to the data txt file.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span></span>)</span>"}, {"fullname": "sapyne.rt_imports.DiracReverberationData.load_data", "modulename": "sapyne.rt_imports", "qualname": "DiracReverberationData.load_data", "kind": "function", "doc": "<p>Load the data from the file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sapyne.rt_imports.REWReverberationData", "modulename": "sapyne.rt_imports", "qualname": "REWReverberationData", "kind": "class", "doc": "<p>Representation of REW reverberation data file.</p>\n"}, {"fullname": "sapyne.rt_imports.REWReverberationData.__init__", "modulename": "sapyne.rt_imports", "qualname": "REWReverberationData.__init__", "kind": "function", "doc": "<p>Initialize the REWReverberationData by importing the data from \nthe specified text file previously exported from REW.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\nPath to the REW data file.</li>\n<li><strong>bands</strong> (str, optional):\nBand resolution of the data. Can be either \"octave\" or \"third\". Default is \"octave\".</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">bands</span><span class=\"o\">=</span><span class=\"s1\">&#39;octave&#39;</span></span>)</span>"}, {"fullname": "sapyne.rt_imports.merge_rew_dfs", "modulename": "sapyne.rt_imports", "qualname": "merge_rew_dfs", "kind": "function", "doc": "<p>Merge the REW dataframes for the specified quantity.\nThe possible quantities are listed in the REW_QUANTITIES list.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong> (List[REWReverberationData]):\nList of REWReverberationData objects.</li>\n<li><strong>quantity</strong> (str, optional):\nQuantity to merge. Default is \"T20 (s)\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pd.DataFrame</strong>: Merged DataFrame with swaped columns and rows. \n(rows are the measurements, columns are the Frequency bands)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sapyne</span><span class=\"o\">.</span><span class=\"n\">rt_imports</span><span class=\"o\">.</span><span class=\"n\">REWReverberationData</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">quantity</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;T20 (s)&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "sapyne.standard", "modulename": "sapyne.standard", "kind": "module", "doc": "<p>This module contains the optimum T60 values given by different standards, \nThis module contains the optimum T60 values given by different standards, \nmainly the \u010cSN 73 0527. It defines various room types and their corresponding \nT60 limits, frequency bands, and optimal T60 dependencies based on room volume.</p>\n\n<p>Constants:\n    FREQUENCIES (list): Standard frequency bands.\n    FREQUENCIES_EXTENDED (list): Extended frequency bands.\n    T60_LIMITS (dict): Dictionary containing T60 limits for different room types.\n    T_OPT_DEPENDENCY (dict): Dictionary containing lambda functions to calculate \n                             optimal T60 based on room volume.\n    VOLUME_LIMITS (dict): Dictionary containing volume limits for different room types.</p>\n\n<p>Classes:\n    RoomType: Dataclass representing a room type with attributes for name, \n              T60 limits, frequencies, optimal T60 dependency, and volume limits.</p>\n\n<p>Variables:\n    ROOM_TYPES (dict): Dictionary containing instances of RoomType for various \n                       room types defined by the \u010cSN 73 0527.</p>\n"}, {"fullname": "sapyne.standard.RoomType", "modulename": "sapyne.standard", "qualname": "RoomType", "kind": "class", "doc": "<p>Dataclass for room types</p>\n"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();